<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>study ECMAScript 2016</title>
</head>
<body>
    



<script>
    /**
    1.数组的解构赋值
        基本用法
        ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。

        以前，为变量赋值，只能直接指定值。

            let a = 1;
            let b = 2;
            let c = 3;
            ES6 允许写成下面这样。

            let [a, b, c] = [1, 2, 3];

        上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。

        本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。

            let [foo, [[bar], baz]] = [1, [[2], 3]];
            foo // 1
            bar // 2
            baz // 3

            let [ , , third] = ["foo", "bar", "baz"];
            third // "baz"

            let [x, , y] = [1, 2, 3];
            x // 1
            y // 3

            let [head, ...tail] = [1, 2, 3, 4];
            head // 1
            tail // [2, 3, 4]

            let [x, y, ...z] = ['a'];
            x // "a"
            y // undefined
            z // []

        如果解构不成功，变量的值就等于undefined。

            let [foo] = [];
            let [bar, foo] = [1];

        以上两种情况都属于解构不成功，foo的值都会等于undefined。

        另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。

            let [x, y] = [1, 2, 3];
            x // 1
            y // 2

            let [a, [b], d] = [1, [2, 3], 4];
            a // 1
            b // 2
            d // 4

        上面两个例子，都属于不完全解构，但是可以成功。

        如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。

            // 报错
            let [foo] = 1;
            let [foo] = false;
            let [foo] = NaN;
            let [foo] = undefined;
            let [foo] = null;
            let [foo] = {};
            
        上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。

        对于 Set 结构，也可以使用数组的解构赋值。

            let [x, y, z] = new Set(['a', 'b', 'c']);
            x // "a"
        
        事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。

            function* fibs() {
                let a = 0;
                let b = 1;
                while (true) {
                    yield a;
                    [a, b] = [b, a + b];
                }
            }

            let [first, second, third, fourth, fifth, sixth] = fibs();
            sixth // 5

        上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。

    */
</script>

<script>
    var a = [];
    for (var i = 0; i < 10; i++) {
        (function(i){
            a[i] = function () {
                console.log(i);
            }
        })(i);     
    }
    a[6](); // 10
</script>

</body>
</html>